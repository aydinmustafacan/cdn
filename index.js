var y=class{static replacePunctuations(t){return t.replace(/[^\w\s]/gi,"")}},I=y;var f=class{constructor(t){let s=I.replacePunctuations(t);this.body=s}},P=f;var g=class{constructor(t){let s=t.body;this.tokens=s.split(" "),this.tokenNumber=this.tokens.length,console.log(this.tokens),console.log("There exist "+this.tokenNumber+" tokens in the query.")}},b=g;var h=class{static positionalIntersect(t,s,e){let n=new Set,d={},c=Object.keys(t).map(o=>Number(o)),p=Object.keys(s).map(o=>Number(o));for(let o of c)if(p.includes(o)){let u=t[o],l=s[o],m=[],a=0,i=0;for(;a<u.length&&i<l.length;)l[i]-u[a]>=0&&l[i]-u[a]<=e?(m.push(l[i]),i++):u[a]<l[i]?a++:i++;m.length>0&&(n.add(o),d[o]=m)}return{matchedDocIds:n,intersectionPositions:d}}};var x=class{constructor(t,s,e){this.tokens=t.tokens,this.invertedIndex=s,this.dictionary=e}applyProximityQuery(){let t=this._extractListOfPostingsLists(),s=t[0];if(t.length===1)return Object.keys(s).map(n=>Number(n));let e=new Set;for(let n=1;n<t.length;n++){let d=t[n],{matchedDocIds:c,intersectionPositions:p}=h.positionalIntersect(s,d,1);if(console.log("matchedDocIds"),console.log(c),console.log("intersectionPositions"),console.log(p),s=p,e=c,c.size===0)break}return Array.from(e)}_extractListOfPostingsLists(){let t=[];for(let s of this.tokens){let e=this.invertedIndex[this.dictionary[s]];e&&t.push(e)}return t}},O=x;var k=class{constructor(t,s,e){this.queryString=t,this.invertedIndex=s,this.dictionary=e}run(){console.log("QueryRunner.run()");let t=new P(this.queryString),s=new b(t);return new O(s,this.invertedIndex,this.dictionary).applyProximityQuery()}},A=k;export{A as default};
//# sourceMappingURL=index.js.map
